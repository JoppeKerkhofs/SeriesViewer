import { app, BrowserWindow, protocol } from "electron";
import { session, ipcMain } from "electron";
import { initialize, enable } from "@electron/remote/main";
import { URL } from "url";
import fs from "fs";
import path from "path";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// import the api calls
import { searchShow, searchSeason, searchEpisode } from "./api/omdbCalls";
import { getOnlineImage } from "./api/onlineImage";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit();
}

const createWindow = (): void => {
	// Create the browser window.
	const mainWindow = new BrowserWindow({
		width: 2000,
		height: 1000,
		autoHideMenuBar: true,
		icon: "src/assets/images/logo.png",
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			nodeIntegration: true,
			contextIsolation: false,
		},
	});

	enable(mainWindow.webContents);

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
	mainWindow.setBackgroundColor("#f8fafc");

	// Open the DevTools.
	mainWindow.webContents.openDevTools();

	ipcMain.on("get-show", (event, name) => {
		searchShow(name).then((data) => {
			// check if the response is 'This is not a series'
			if (data === "This is not a series") {
				event.reply("get-show", "This is not a series");
				return;
			}
			event.reply("get-show", data);
		});
	});

	ipcMain.on("get-season", (event, name, seasonNumber) => {
		searchSeason(name, seasonNumber).then((data) => {
			event.reply("get-season", data);
		});
	});

	ipcMain.on("get-episode", (event, name, seasonNumber, episodeNumber) => {
		searchEpisode(name, seasonNumber, episodeNumber).then((data) => {
			event.reply("get-episode", data);
		});
	});

	ipcMain.on("get-online-image", (event, url, location) => {
		// get the poster
		getOnlineImage(url, location).then((poster: string) => {
			event.reply("get-online-image", poster);
		});
	});

	ipcMain.on("load-local-file", (event, { location, requestId }) => {
		// Get the file path
		const filePath = location;
		// check if the file exists
		if (!fs.existsSync(filePath)) {
			event.reply(`load-local-file-${requestId}`, "error");
			return;
		}

		// Check the file type
		if (filePath.endsWith(".jpg") || filePath.endsWith(".png")) {
			// If it's an image file, read it and send it as a data URL
			fs.readFile(filePath, (err, data) => {
				if (err) {
					console.error("Error reading image file:", err);
					event.reply(`load-local-file-${requestId}`, "error");
				} else {
					const dataUrl = `data:image/${path
						.extname(filePath)
						.slice(1)};base64,${data.toString("base64")}`;
					event.reply(`load-local-file-${requestId}`, dataUrl);
				}
			});
		} else {
			// For other file types, send back an error
			event.reply(`load-local-file-${requestId}`, "error");
		}
	});
};

app.on("ready", () => {
	// Set Content Security Policy
	session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
		callback({
			responseHeaders: {
				...details.responseHeaders,
				"Content-Security-Policy": [
					"default-src 'self' 'unsafe-inline' data: media-loader:; script-src 'self' 'unsafe-eval'",
				],
			},
		});
	});

	// Create custom protocol for local media loading
	protocol.registerFileProtocol("media-loader", (request, callback) => {
		const url = request.url.replace("media-loader://", "");
		try {
			return callback(url);
		} catch (err) {
			console.error(err);
			return callback("404");
		}
	});

	initialize();

	// Create Window
	createWindow();
});

app.on("window-all-closed", () => {
	if (process.platform !== "darwin") {
		app.quit();
	}
});

app.on("activate", () => {
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow();
	}

	// Set the permission request handler
	session.defaultSession.setPermissionRequestHandler(
		(webContents, permission, callback) => {
			const parsedUrl = new URL(webContents.getURL());

			// Check if the request comes from OMDB API
			if (
				permission === "notifications" &&
				parsedUrl.origin === "https://www.omdbapi.com/"
			) {
				callback(true); // Allow the permission request
			} else {
				callback(false); // Deny the permission request
			}
		}
	);
});
